class Solution {
public:
    int helper(int n, vector<vector<int>>& graph, int tres,int src) {
        vector<int> dist(n, INT_MAX);
        dist[src] = 0;

        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
        pq.push({0, src}); // {dist, city}

        while(!pq.empty()){
            vector<int> temp = pq.top();
            pq.pop();

            int curr = temp[0];
            int city = temp[1];

            if(curr > dist[city]) continue;

            for(int i = 0; i < n; i++){
                if(graph[city][i] && dist[i] > curr + graph[city][i]){
                    dist[i] = curr + graph[city][i];
                    pq.push({dist[i], i});
                }
            }
        }

        int ans = 0;
        for(int i = 0; i < n; i++){
            if(i != src && dist[i] <= tres) ans++;
        }
        return ans;
    }

    int findTheCity(int n, vector<vector<int>>& edges, int tres) {

        int ans = INT_MAX;
        int idx = -1;

        vector<vector<int>> graph(n, vector<int>(n, 0));
        for(auto &x:edges){
            graph[x[0]][x[1]] = x[2];
            graph[x[1]][x[0]] = x[2];
        }

        for(int i = 0; i < n; i++){
            int temp = helper(n, graph, tres, i);

            if(temp <= ans){
                ans = temp;
                idx = i;
            }
        }

        return idx;
    }
};
